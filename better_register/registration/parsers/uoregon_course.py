__author__ = 'tanner'

from bs4 import BeautifulSoup
import string
import re


def remove_nbsp(text):
    """
    removes the non breaking space characters from a string
    :param text:
    :return:
    """
    pattern = re.compile(u'\xa0')
    return pattern.sub('', text)


def to_int(in_string):
    """
    converts the in_string to an integer if it can. otherwise
    just returns the string
    :param in_string: the string to try and cast to int
    :return: the casted string or just the string
    """
    try:
        return int(in_string)
    except ValueError:
        return in_string


def parse_time(time_str):
    """
    Replaces the time entry with a start and end time entry
    Splits start and end time, strip leading zero in military time and convert to int
    :param time_str: string of start and end times e.g. 1800-1850
    :return: None
    """
    start, end = [int(t.lstrip('0')) for t in time_str.split('-')]
    return dict(start=start, end=end)


def parse_meetings(days_str,time_str):
    """
    Since classes can have diffrent meetings on diffrent days we parse the time into day, time pairs.

    parse_meetings('mf',1600-1650)
    >{'m':{start:1600,end:1650}, 'f':{start:1600,end:1650}}
    :param days: string of days mwf
    :param time: string fo start and end times
    :return:a dict of days mapped to start and end times
    """
    times = parse_time(time_str)
    meetings = {c:times for c in days_str}
    return meetings

def has_multiple_times(table_row):
    """
    Checks a vitals table row to see if the class meets at a different time on diffrent days.
    e.g. 1600-1600 on mondays and 1500-1550 and fridays.
    :param table_row:
    :return: boolean
    """
    sibling = table_row.next_sibling
    pattern = r'(\d{4}-\d{4})'
    return re.match(pattern, sibling.text)

def parse_extra_time(table_row):

    if has_multiple_times(table_row):





def parse_vitals(table_row):
    """
    :param table_row
    A <TR> beautiful soup tag structured as
    <TR>
        <TD> class_type  i.e(Lecture)
        <TD> CRN
        <TD> Avail
        <TD> Max
        <TD> Time
        <TD> Day
        <TD> Location
        <TD> Instructor
        <TD> Note
    :return: A dictionary with the above titles as keys and the
    text from the <TD> as the values
    """
    rows = [to_int(remove_nbsp(tag.text)) for tag in [child for child in table_row.children if child != u'\n']]
    labels = ['class_type', 'crn', 'avail', 'max', 'time', 'day', 'location', 'instructor', 'notes']
    label_mapping = dict(zip(labels, rows))
    label_mapping['meetings'] = parse_meetings(label_mapping['day'], label_mapping['time'])



    return label_mapping

def get_vitals(soup):
    """
    Finds the tag that contains the vitals for the class and returns the vitals parsed into a dict.
    :param soup: beautiful soup obj
    :return: dictonary generated by parse_vitals
    """
    vitals_tag = soup.find('td', class_='dddead', text='Location').parent.find_next_siblings('tr')[0]
    vitals_dict = parse_vitals(vitals_tag)


def get_term(soup):
    """
    Returns the term and year of the class
    :param soup: a beautiful soup obj
    returns the term and the year
    """
    term_tag = soup.find('h2')
    term, year = term_tag.text.split(' ')
    return term, int(year)


def parse_course_code(text):
    """
    Finds the class codes of the form: CIS 210 in a sentence
    :param text: string to find class code in or list of strings
    :return: list of tuples of class code and number

    parse_class_code('CIS 313 with Andrezj builds character.')
    > [('CIS',313)]
    parse_class_code('CIS 451 and HIST 101')
    > [('HIST',101), ('CIS',451)]
    """
    text = text.strip(string.punctuation).split(' ')
    codes = [(text[i], int(text[i + 1])) for i in range(len(text)) if i + 1 < len(text) and
               text[i].isupper() and text[i + 1].isdigit()]
    return codes


def get_prereqs(soup):
    """
    Gets the subject number pairs in the prereq string.
    :rtype :
    :param soup: beautifulsoup obj of the course page
    :return: list of (subject,number)


    get_prereqs('Prereq: CIS 210 and MATH 112')
    > [('CIS',210) ,('MATH',112)]
    """
    prereq_text = soup.find(text=re.compile('Prereq:'))
    if not prereq_text:
        return []
    return parse_course_code(prereq_text)


def parse_associated_sections(soup):
    """
    Gets the associated sections of a class.
    Found by searching for element:
    <TR>
        <TD COLSPAN="8" CLASS="dddead" width="536"><br>Associated Sections</TD>
    Then parsing the sibling rows which are the vitals for the associated section.

    :param soup: a beautifulsoup object of the class page
    :return: a list of dictionaries made from get_vitals()
    """
    associated_section_header = soup.find('td', text='Associated Sections').parent
    return [parse_vitals(sib) for sib in associated_section_header.find_next_siblings('tr')]


def get_notes(soup):
    """

    :param soup:
    :return:
    """
    note_divs = soup.find_all('div', class_='notes')
    notes = []
    for note_div in note_divs:
        note_text = note_div.text.split('-')
        if not note_text[0]: #Note code is a image
            note_text[0] = note_div.img['alt']  # The alt text is the title of the note
        notes += tuple(note_text)
    return notes


def get_instructors(soup):
    """
    We use this instead of the vitals because the course evals
    need the full name. And the vitals only give us the lastname  first initial
    :param soup:
    :return:
    """
    instructor_elements = soup.find_all('td', text='Instructor:')
    instructors = []
    for element in instructor_elements:
        anchor_tag = element.find_next_sibling('td').a
        name = anchor_tag['target']
        email = anchor_tag['href'].replace('mailto:', '')
        instructors.append(dict(name=name, email=email))

    return instructors


def get_gen_eds(title_text):
    """
    The gen_ed codes of the form >4 are contained in the title text for some reason. So we extract those here.
    :param title_text: the title string
    :return: all the gen ed categories of the course, empty list if none

    parse_gen_eds('PHIL 110 Postmodernist Bullshitting >IP >2')
    >['>IP','>2']
    parse_gen_eds('BIS 400 Dude I have a great startup idea. I just need you to code it')
    > []
    """
    return [i for i in title_text.split(' ') if '>' in i]


def get_title_credit_text(soup):
    """
    The tags cointaing the credits and the title string are in the same TR so we get both strings here.
    :rtype : list
    :param soup: beautifulsoup obj
    :return: [title_tag, credit_]

    get_title_credit_text(course_soup)
    >['CIS 210 Computer Science I >4', '4.00 cr.']
    """
    return [remove_nbsp(tag.text) for tag in soup.find(class_="datadisplaytable").find('tr').find_all('td')]


def get_credits(credit_text):
    """
    Returns the number of credits the course is worth.
    :param credit_text: the tag containing the credits
    :return:
    """
    return float(credit_text.split(' ')[0])


def parse_title(title_text):
    """
    The title, subject, number and gen eds are stored in the title. So we parse an return them here.
    :param title_text: the tag containing the title string
    :return: the course code
    """

    subject, number = parse_course_code(title_text)[0]
    end_of_number = title_text.find(str(number))+3
    gen_ed_start = title_text.find('>')  # If there's a > in the title its a gen ed
    gen_eds = get_gen_eds(title_text)

    if gen_ed_start != -1:
        title = title_text[end_of_number:gen_ed_start]  # Title stops where gen ed begins
    else:
        title = title_text[end_of_number:]

    return subject, number, gen_eds, title.strip()


def get_course_fee(soup):
    """
    Gets the course fee of a course returns 0.0 if there is no fee.
    :param soup: beautiful soup obj
    :return: float of course fee, 0.0 if no fee
    """
    tag = soup.find('td', text=re.compile('\$'))
    if tag:
        return float(tag.text.replace('$', ''))
    return 0.0


def parse_primary_course(soup):
    """
    :param soup:
    :return:
    """

    primary_dict = get_vitals(soup)

    title_text, credit_text = get_title_credit_text(soup)
    subject, number, gen_eds, title = parse_title(title_text)
    term, year = get_term(soup)

    primary_dict['term'] = term
    primary_dict['title'] = title
    primary_dict['year'] = year
    primary_dict['subject'] = subject
    primary_dict['number'] = number
    primary_dict['credits'] = get_credits(credit_text)
    primary_dict['gen_eds'] = gen_eds
    primary_dict['prereqs'] = get_prereqs(soup)
    primary_dict['instructors'] = get_instructors(soup)
    primary_dict['notes'] = get_notes(soup)
    return primary_dict


def parse_associated_section(soup, offering):
    associated_section = get_vitals(soup)
    associated_section['instructors'] = get_instructors(soup)
    associated_section['offering'] = offering
    return associated_section


def parse_results_page(soup):
    """

    :param soup:
    :return:
    """

























